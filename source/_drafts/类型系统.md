Named Type == 预声明（简单）类型 + 用户自定义类型

预声明类型 == 简单类型

预声明类型 20 个：

布尔型：bool

整型：

- int int8 int16 int32 int64
- uint uint8 uint16 uint32 uint64
- uintptr

浮点型：

- float32
- float64

复数：

- complex64
- complex128

字符：

- byte（uint8）
- rune（int32）

字符串：string

接口：error

Unamed Type == Type Literal == 复合类型

underlying type

1. 预声明类型（Per-declared types）和类型字面量（type literals）的底层类型是它们自身。
2. 自定义类型 `type newtype oldtype`中 newtype 的底层类型是逐层向下查找，直到查到的 oldtype
   是预声明类型（Per-declared types）或类型字面量（type literals）为止。

类型相同：

1. 两个命名类型相同的条件是：两个类型声明的语句完全相同；
2. 命名类型和未命名类型永远不相同；
3. 两个未命名类型相同的条件是它们的类型声明字面量的结构相同，并且内部元素的类型相同；
4. 通过类型别名语句声明的两个类型相同。

类型赋值：

类型为 T1 的变量 a 赋值给类型为 T2 的变量

1. T1 和 T2 的类型相同；
2. T1 和 T2 具有相同的底层类型，并且 T1 和 T2 至少有一个是未命名类型；
3. T2 是接口类型，T1 是具体类型，T1 的方法集是 T2 方法集的超集；
4. T1 和 T2 都是通道类型，它们拥有相同的元素类型，并且 T1 和 T2 中至少有一个是未命名类型；
5. a 是预声明标识符 nil，T2 是 pointer function slice map channel interface 类型中的一个；
6. a 是一个字面常量值，可以用来表示类型 T 的值。

类型强制转换：

语法：`var a T = (T)(b)`

使用括号将类型和要转换的变量或表达式的值括起来。

1. b 可以直接赋值给 T 类型变量；
2. b 的类型和 T 具有相同的底层类型。
3. b 的类型和 T 都是未命名的指针类型，并且指针指向的类型具有相同的底层类型；
4. b 的类型和 T 都是整型或浮点型；
5. b 的类型和 T 都是复数类型；
6. b 是整数值或 []byte 类型的值， T 是 string 类型；
7. b 是一个字符串， T 是 []byte 或 []rune。

注意：

1. 数值类型和 string 类型之间的相互转换可能造成值部分丢失，其他的转换不会造成值的改变，可以使用标准库 strconv；
2. Go 语言没有语言机制支持指针和 interger 之间的直接转换，可以使用标准库中的 unsafe 包进行处理。

# 类型方法

## 自定义类型

语法：`type newtype oldtype`

- 使用关键字 `type`；
- oldtype 可以是自定义类型、预声明类型、未命名类型中的任意一种；
- newtype 是新类型的标识符，与 oldtype 具有相同的底层类型，并且都继承了底层类型的操作集合；
- newtype 和 oldtype 是两个完全不同的类型，newtype 不会继承 oldtype 的方法；
- 自定义类型都是命名类型。

### 自定义 struct 类型

struct 类型：

- Go 语言自定义类型的普遍的形式；
- Go 语言类型扩展的基石；
- Go 语言面向对象承载的基础。

struct 初始化：

```
type Person struct {
   name string
   age int
}
```

1. 按照字段顺序进行初始化：

```
a := Person{"andes",18}

b := Person{
   "andes",
   18,
}

c := Person{
   "andes",
   18}
```

这不是一种推荐的方法，一旦结构增加字段，则不得不修改顺序初始化语句。

2. 指定字段名进行初始化：

```
a := Person{name:"andes",age:18}

b := Person{
   name: "andes",
   age: 18,
}

c := Person{
   name: "andes",
   age: 18}
```

这是一种推荐的方法，一旦结构增加字段，则不用修改初始化语句。

**注意：如果上述两种结构的初始化语句结尾的“}”独占一行，则最后一个字段的后面一定要带上逗号。**

3. 使用 new 创建函数，字段默认初始化为其类型的零值，返回值是指向结构的指针。

```
p := new(Person)
```

这种方法不常用，一般使用 struct 都不会将所有字段初始化为零值。

4. 一次初始化一个字段。

```
p := Person{}

p.name = "andes"
p.age = 18
```

这种方法不常用，这是一种结构化的编程思维，没有封装，违背了 struct 本身抽象封装的理念。

5. 使用构造函数进行初始化。

这是推荐的一种方法，当结构发生变化时，构造函数可以屏蔽细节。

结构字段的特点

- 可以是任意类型：基本类型、接口类型、指针类型、函数类型；
- 类型名必须唯一；
- 支持内嵌自身的指针，这也是实现树形和链表等复杂数据结构的基础。

匿名字段

在定义 sruct 的过程中，如果字段只给出字段类型，没有给出字段名，则称这样的字段为“匿名字段”。

- 被匿名嵌入的字段必须是命名类型或命名类型的指针，类型字面量不能作为匿名字段使用；
- 匿名字段的字段名默认就是类型名（如果匿名字段是指针类型，则默认的字段名就是指针指向的类型名）；
- 一个结构里面不能同时存在某一类型及其指针类型的匿名字段，原因是二者字段名相同；
- 如果嵌入字段类型为其他包的可导出类型，则需要加上包名。

## 方法

Go 语言的类型方法是一种对类型行为的封装。

可看作特殊类型的函数：其显式地将对象实例或指针作为函数的第一个参数，并且参数名可以自行指定；

- 不强制要求一定是 this 或 self；
- 将对象实例或指针称为方法的接收者。

语法：

```
func (t TypeName)MethodName(ParamList)(ReturnList) {
   //Method body
}

func (t *TypeName)MethodName(ParamList)(ReturnList) {
   //Method body
}
```

- 非命名类型和接口不能自定义方法；
- 预声明类型不能自定义方法；
- 类型的定义和方法的定义必须在同一个包中；
- 方法名称以大写字母开头的方法可以在包外被访问；
- 新类型不能调用原有类型的方法；
- 新类型继承其底层类型的操作集。

# 方法调用

## 一般调用

`TypeInstanceName.MethodName(ParamList)`

## 方法值（method value）

`TypeInstanceName.MethodName`

- 是一个函数类型变量，可以赋值给其他变量，并像普通的函数名一样使用；
- 带有闭包的函数变量，其底层实现原理与带有闭包的匿名函数类似：
  - 接收值被隐式地绑定到方法值的闭包环境中；
  - 后续调用不需要再显式地传递接收者。

## 方法表达式（method expression）

```
TypeName.MethodName

(*TypeName).MethodName
```

将类型方法调用显式地转换为函数调用，接收者（receiver）必须显式地传递进去。

- 可以看作函数名：首个参数是接收者的实例或指针；
- 编译器不会做自动转换。

## 方法集（method set）

方法和函数的实参传递都是值拷贝：

- 如果接收者是值类型，则传递的是值的副本；
- 如果接收者是指针类型，则传递的是指针的副本。
